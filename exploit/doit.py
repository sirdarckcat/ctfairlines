#!/usr/bin/python3
import itertools, os, socket, struct, time

full_charset= b"?\n{}ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def ascii_to_keymap(c):
    if c == ord('{'):
        return 2
    if c == ord('}'):
        return 3
    if c >= 0x61 and c <= (0x61 + 26):
        c -= 0x20
    if c >= 0x41 and c <= (0x41 + 26):
        return c - (0x41) + 4
    return 0

def lights_generator():
    rx = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    rx.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    rx.bind(("0.0.0.0", 34568))
    while True:
        data = rx.recv(1024)
        if data[0x14:0x16] == b"\x07\xC1":
            continue
        elif data[0x14:0x16] == b"\x07\xC4":
            lights = struct.unpack(">I", data[0x0e:0x12])
            yield(lights[0])
        else:
            continue

lighter = lights_generator()

def get_lights(req):
    global lighter
    os.system("/cdls/unlock '" + req + "' >/dev/null")
    val = 0
    while val == 0:
        val = next(lighter)
    next(lighter)
    return val

used_charset_num = get_lights("")
print(bin(used_charset_num))
used_charset = ""
for e in range(32):
    if used_charset_num & (1<<e) > 0:
        print(chr(full_charset[e]), bin(ascii_to_keymap(full_charset[e])))
        used_charset+=(chr(full_charset[e]))

def bin_permut_even(prefix=''):
    yield(prefix+'00')
    yield(prefix+'11')
    zo=bin_permut_odd(prefix+'01')
    oz=bin_permut_odd(prefix+'10')
    while True:
        yield next(zo)
        yield next(oz)

def bin_permut_odd(prefix=''):
    yield(prefix+'01')
    yield(prefix+'10')
    zz = bin_permut_odd(prefix+'00')
    oo = bin_permut_odd(prefix+'11')
    while True:
        yield next(zz)
        yield next(oo)

def bin_permut_all(prefix=''):
    yield(prefix+'00')
    yield(prefix+'01')
    yield(prefix+'10')
    yield(prefix+'11')
    zz = bin_permut_all(prefix+'00')
    zo = bin_permut_all(prefix+'01')
    oz = bin_permut_all(prefix+'10')
    oo = bin_permut_all(prefix+'11')
    while True:
        yield next(zz)
        yield next(zo)
        yield next(oz)
        yield next(oo)

def init_permut(needed1, needed0):
    options = itertools.product("01",repeat=needed1+needed0)
    used = []
    discarded = []
    for opt in options:
        binopt = ''.join(opt)
        if binopt.count('1') == needed1:
            yield binopt
            used.append(bin_permut_even(binopt))
        else:
            discarded.append(bin_permut_all(binopt))
    while True:
        for d in used:
            r = next(d)
            if r.count('1') >= needed1 and r.count('0') >= needed0:
                if (r.count('1') - needed1) % 2 == 0:
                    yield r
        for d in discarded:
            r = next(d)
            if r.count('1') >= needed1 and r.count('0') >= needed0:
                if (r.count('1') - needed1) % 2 == 0:
                    yield r

def get_needed_bits_at(n, b):
    bits_needed = 0
    for c in used_charset:
        c_n = ascii_to_keymap(ord(c))
        c_b = (c_n>>n) & 1
        if c_b == b:
            bits_needed += 1
    return bits_needed


def get_matching_p(bitseq, n):
    charset = used_charset[:]
    blacklist = []
    res = ''
    for seq in bitseq:
        f = ''
        for c in charset:
            if c in blacklist:
                continue
            c_n = ascii_to_keymap(ord(c))
            c_b = str((c_n>>n) & 1)
            if seq == c_b:
                f = c
                blacklist.append(c)
                break
        if f:
            res += f
        else:
            if n < 2:
                c_extra = 0b100 + (int(seq,2)<<n)
            else:
                c_extra = 0b010 + (int(seq,2)<<n)
            res += chr(full_charset[c_extra])
    return res

def serialize(attempt):
    for b in range(5):
        t = ""
        for x in attempt:
            k = ascii_to_keymap(x)
            c = chr(x)
            if k & (1<<b):
                t+="1"
            else:
                t+="0"
        print(b, t)

def mutateat(n):
    sw=0
    p_0 = init_permut(get_needed_bits_at(n, 1), get_needed_bits_at(n, 0))
    for x in p_0:
        sw+=1
        c = get_matching_p(x, n)
        l = get_lights(c)
        if (l>>n)&1 == 0:
            print(sw)
            return x


prefixes = []
for n in range(5):
    sol = mutateat(n)
    prefixes.append(sol)
    print(n, sol, get_matching_p(sol, n))

def advance_solution(prefix):
    for x in bin_permut_even(prefix):
        c = get_matching_p(x, n)
        l = get_lights(c)
        if (l>>n)&1 == 0:
            return x

flag = ""
idx = 0
while True:
    c = 0
    for n in range(5):
        while len(prefixes[n]) <= idx:
            prefixes[n] = advance_solution(prefixes[n])
        c += int(prefixes[n][idx],2)<<n
    flag_n = chr(full_charset[c])
    flag += flag_n
    print(flag)
    idx += 1
    if flag_n == '}':
        break

os.system("echo " + flag + " >/tmp/flag")

while True:
    os.system("/cdls/unlock '" + flag + "'")
    time.sleep(0.1)
