#!/usr/bin/python3
import itertools, os, socket, struct, sys

full_charset= b"?\n{}ABCDEFGHIJKLMNOPQRSTUVWXYZ"
known_prefix= b'CTF{'

def ascii_to_keymap(c):
    if c == ord('{'):
        return 2
    if c == ord('}'):
        return 3
    if c >= 0x61 and c <= (0x61 + 26):
        c -= 0x20
    if c >= 0x41 and c <= (0x41 + 26):
        return c - (0x41) + 4
    return 0

def lights_generator():
    rx = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    rx.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    rx.bind(("0.0.0.0", 34568))
    while True:
        data = rx.recv(1024)
        if data[0x14:0x16] == b"\x07\xC1":
            continue
        elif data[0x14:0x16] == b"\x07\xC4":
            lights = struct.unpack(">I", data[0x0e:0x12])
            yield(lights[0])
        else:
            continue

def send_keys(req):
    os.system("/cdls/unlock '" + req + "' >/dev/null")


last_fake = ""
saved_flag = ""
def fake_generator():
    def bitmask(string):
        bitmask = 0
        for char in string:
            bitmask ^= 1 << ascii_to_keymap(ord(char))
        return bitmask
    flag_bitmask = bitmask(saved_flag)
    while True:
        fake_bitmask = bitmask(last_fake)
        if fake_bitmask != flag_bitmask:
            yield fake_bitmask ^ flag_bitmask
        else:
            xor_sum = 0
            for idx in range(len(last_fake)):
                if idx < len(saved_flag):
                    xor_sum |= ascii_to_keymap(ord(last_fake[idx])) ^ ascii_to_keymap(ord(saved_flag[idx]))
            yield xor_sum

def fake_sender(req):
    global last_fake
    last_fake = req

chrctr = 0
strctr = 0
memctr = 0
memory = {}

if len(sys.argv) < 2:
    lighter = lights_generator()
    sender = send_keys
else:
    lighter = fake_generator()
    sender = fake_sender
    saved_flag = sys.argv[1]
    print("FAKING CIRCUIT WITH %s"%saved_flag)
def get_lights(req):
    global chrctr, strctr, memctr
    if req in memory:
        memctr += 1
        return memory[req]
    strctr += 1
    chrctr += len(req)
    sender(req)
    val = 0
    while val == 0:
        val = next(lighter)
    next(lighter)
    memory[req]=val
    return val

starts = ['' for _ in range(5)]
for i in range(len(known_prefix)):
    c = ascii_to_keymap(known_prefix[i])
    for j in range(5):
        starts[j] += str((c>>j)&1)

used_charset_num = get_lights("")
print('used charset', bin(used_charset_num))
used_charset = ""
for e in range(32):
    if used_charset_num & (1<<e) > 0:
        print('used', chr(full_charset[e]), bin(ascii_to_keymap(full_charset[e]))[2:].zfill(5))
        used_charset+=(chr(full_charset[e]))

def bin_permut_even(prefix=''):
    yield(prefix+'00')
    yield(prefix+'11')
    zo=bin_permut_odd(prefix+'01')
    oz=bin_permut_odd(prefix+'10')
    while True:
        yield next(zo)
        yield next(oz)

def bin_permut_odd(prefix=''):
    yield(prefix+'01')
    yield(prefix+'10')
    zz = bin_permut_odd(prefix+'00')
    oo = bin_permut_odd(prefix+'11')
    while True:
        yield next(zz)
        yield next(oo)

def bin_permut_all(prefix=''):
    yield(prefix+'00')
    yield(prefix+'01')
    yield(prefix+'10')
    yield(prefix+'11')
    zz = bin_permut_all(prefix+'00')
    zo = bin_permut_all(prefix+'01')
    oz = bin_permut_all(prefix+'10')
    oo = bin_permut_all(prefix+'11')
    while True:
        yield next(zz)
        yield next(zo)
        yield next(oz)
        yield next(oo)

def init_permut(needed1, needed0):
    options = itertools.product("01",repeat=needed1+needed0)
    used = []
    discarded = []
    for opt in options:
        binopt = ''.join(opt)
        if binopt.count('1') == needed1:
            yield binopt
            used.append(bin_permut_even(binopt))
        else:
            discarded.append(bin_permut_all(binopt))
    while True:
        for d in used:
            r = next(d)
            if r.count('1') >= needed1 and r.count('0') >= needed0:
                if (r.count('1') - needed1) % 2 == 0:
                    yield r
        for d in discarded:
            r = next(d)
            if r.count('1') >= needed1 and r.count('0') >= needed0:
                if (r.count('1') - needed1) % 2 == 0:
                    yield r

def get_needed_bits_at(n, b):
    bits_needed = 0
    for c in used_charset:
        c_n = ascii_to_keymap(ord(c))
        c_b = (c_n>>n) & 1
        if c_b == b:
            bits_needed += 1
    return bits_needed


def get_matching_p(bitseq, n):
    charset = used_charset[:]
    blacklist = []
    res = ''
    for seq in bitseq:
        f = ''
        for c in charset:
            if c in blacklist:
                continue
            c_n = ascii_to_keymap(ord(c))
            c_b = str((c_n>>n) & 1)
            if seq == c_b:
                f = c
                blacklist.append(c)
                break
        if f:
            res += f
        else:
            if n < 2:
                c_extra = 0b100 + (int(seq,2)<<n)
            else:
                c_extra = 0b010 + (int(seq,2)<<n)
            res += chr(full_charset[c_extra])
    return res

def serialize(attempt):
    for b in range(5):
        t = ""
        for x in attempt:
            k = ascii_to_keymap(x)
            c = chr(x)
            if k & (1<<b):
                t+="1"
            else:
                t+="0"
        print('serialize(%s)'%attempt, b, t)

def mutateat(n):
    global shortcut
    sw=0
    p_0 = init_permut(get_needed_bits_at(n, 1), get_needed_bits_at(n, 0))
    for x in p_0:
        sw+=1
        c = get_matching_p(x, n)
        if not x.startswith(starts[n]):
            continue
        l = get_lights(c)
        if (l>>n)&1 == 0:
            print('mutateat(%s) took %s'%(n,sw))
            return x


prefixes = []
for n in range(5):
    sol = mutateat(n)
    prefixes.append(sol)
    print('prefixes', n, sol, get_matching_p(sol, n))

def advance_solution(prefix, n):
    for x in bin_permut_even(prefix):
        c = get_matching_p(x, n)
        l = get_lights(c)
        if (l>>n)&1 == 0:
            return x

flag = ""
idx = 0
while True:
    c = 0
    for n in range(5):
        while len(prefixes[n]) <= idx:
            prefixes[n] = advance_solution(prefixes[n], n)
        c += int(prefixes[n][idx],2)<<n
    flag_n = chr(full_charset[c])
    flag += flag_n
    print(flag,end='\r')
    idx += 1
    if flag_n == '}':
        print(flag)
        break

if saved_flag:
    print('Solving this flag takes', strctr/1000, 'minutes')
    exit(0)

os.system("echo " + flag + " >/tmp/flag")

import time
while True:
    os.system("/cdls/unlock '" + flag + "'")
    time.sleep(0.1)
